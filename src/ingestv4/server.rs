use std::sync::Arc;
use std::sync::atomic::{AtomicU64, Ordering};

use futures::{
    future::{self, Ready},
    prelude::*,
};
use tarpc::{
    client,
    context,
    server,
    server::Channel,
};
use tokio::time::Duration;

// This is the service definition. It looks a lot like a trait definition.
// It defines one RPC, hello, which takes one arg, name, and returns a String.
#[tarpc::service]
trait World {
    /// Returns a greeting for name.
    async fn hello(name: String) -> String;
}

// This is the type that implements the generated World trait. It is the business logic
// and is used to start the server.
#[derive(Clone)]
struct HelloServer(Arc<AtomicU64>);

impl HelloServer {
    fn inner(&self) -> Arc<AtomicU64> {
        Arc::clone(&self.0)
    }
}

impl World for HelloServer {
    // Each defined rpc generates two items in the trait, a fn that serves the RPC, and
    // an associated type representing the future output by the fn.

    type HelloFut = Ready<String>;

    fn hello(self, _: context::Context, name: String) -> Self::HelloFut {
        future::ready(format!("client message: {}, server state: {}", name, self.0.load(Ordering::SeqCst)))
    }
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let (client_transport, server_transport) = tarpc::transport::channel::unbounded();

    let hs = HelloServer(Arc::new(AtomicU64::new(0)));
    let arc = hs.inner();

    let server = server::BaseChannel::with_defaults(server_transport);
    tokio::spawn(server.execute(hs.serve()));
    tokio::spawn(async {
        // wait for server to accept connections
        tokio::time::sleep(Duration::from_millis(1000)).await;

        // WorldClient is generated by the #[tarpc::service] attribute. It has a constructor `new`
        // that takes a config and any Transport as input.
        let mut client = WorldClient::new(client::Config::default(), client_transport).spawn();

        for i in 0u64.. {
            tokio::time::sleep(Duration::from_millis(1000)).await;
            // The client has an RPC method for each RPC defined in the annotated trait. It takes the same
            // args as defined, with the addition of a Context, which is always the first arg. The Context
            // specifies a deadline and trace information which can be helpful in debugging requests.
            let hello = client.hello(context::current(), format!("{}", i)).await.expect("rpc call failed");
            println!("{}\n", hello);
        }
    });

    // here it the interesting part
    loop {
        std::thread::sleep(std::time::Duration::from_millis(1000));

        let old = arc.fetch_add(1, Ordering::SeqCst);
        println!("setting server state to {}, old was: {}", old + 1, old);
    }
}